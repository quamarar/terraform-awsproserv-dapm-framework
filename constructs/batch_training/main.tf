locals {
  cidr            = "172.30.0.0/16"
  azs             = slice(data.aws_availability_zones.available.names, 0, 3)
  private_subnets = [for k, v in local.azs : cidrsubnet(local.cidr, 2, k)]

  context = "training"

  const_glue_job_path = "${path.module}/python"

  batch_compute_environments = coalesce(var.batch_compute_environments, {
    training = {
      min_vcpus      = 0
      max_vcpus      = 216
      desired_vcpus  = 0
      instance_types = ["m5.large"]
      type           = "EC2"
    }
  })

  vpc_endpoints = {
    ecr_api = {
      service = "ecr.api"
    }
    ecr_dkr = {
      service = "ecr.dkr"
    }
    s3 = {
      service         = "s3"
      service_type    = "Gateway"
      route_table_ids = flatten([module.vpc.private_route_table_ids])
    }
    dynamodb = {
      service         = "dynamodb"
      service_type    = "Gateway"
      route_table_ids = flatten([module.vpc.private_route_table_ids])
    }
    ecs = {
      service = "ecs"
    }
    ecs_agt = {
      service = "ecs-agent"
    }
    ecs-tel = {
      service = "ecs-telemetry"
    }
    ssm = {
      service = "ssm"
    }
    ec2messages = {
      service = "ec2messages"
    }
    ssmmessages = {
      service = "ssmmessages"
    }
    logs = {
      service = "logs"
    }
  }
}

module "training_construct" {
  source = "../../"

  context       = local.context
  use_case_name = var.use_case_name
  name_prefix   = var.name_prefix
  environment   = var.environment

  ddb_params = var.ddb_params
  utils_path = var.utils_path

  const_glue_job_path   = local.const_glue_job_path
  evaluation_job_params = var.evaluation_job_params
  gatekeeper_job_params = var.gatekeeper_job_params

  eap_dq_bucket_name = var.eap_dq_bucket_name
  ecr_attributes     = var.ecr_attributes

  sagemaker_processing_job_execution_role_arn = var.sagemaker_processing_job_execution_role_arn

  batch_container_properties = var.batch_container_properties

  batch_compute_environments = { for k, v in local.batch_compute_environments : k => {
    name_prefix = replace("${var.name_prefix}-${k}", "_", "-")
    compute_resources = merge({
      security_group_ids = [module.vpc_endpoint_security_group.security_group_id]
      subnets            = module.vpc.private_subnets
      # Note - any tag changes here will force compute environment replacement
      # which can lead to job queue conflicts. Only specify tags that will be static
      # for the lifetime of the compute environment
      tags = {
        # This will set the name on the Ec2 instances launched by this compute environment
        Name = replace("${var.name_prefix}-${k}-instance", "_", "-")
      }
    }, v)
    }
  }

  s3_configs = var.s3_configs
}

/* -------------------------------------------------------------------------- */
/*             Below resources are specific to Training construct             */
/* -------------------------------------------------------------------------- */

locals {

  /* -------------------------- Exposed events params ------------------------- */

  events_from_evaluation = {
    data_quality = {
      source_pattern = "${var.use_case_name}.dataquality"
      description    = "Data quality event rule. Generated by evalution_summary"
    }
    feature_store = {
      description    = "Feature store event rule. Generated by evalution_summary"
      source_pattern = "${var.use_case_name}.feature_store"
    }
    model_monitoring = {
      description    = "Model Monitoring event rule. Generated by evalution_summary"
      source_pattern = "${var.use_case_name}.modelquality"
    }
  }

  sm_registry_approval_params = {
    # ensure to match key with lambda function code
    winner_algorithm = {
      description = "winner algorithm. This is updated by sm model registry approval event. Referred by inference."
    }
    approved_model_prefix_path = {
      description = "Current approved model prefix. This is updated by sm model registry approval event. Referred by inference."
    }
  }
}

/* ----------------------------------- VPC ---------------------------------- */

data "aws_availability_zones" "available" {
  state = "available"
}

module "vpc" {
  source = "github.com/MSIL-Analytics-ACE/terraform-common-modules//terraform-aws-vpc?ref=v1.0.0"

  name = "${var.name_prefix}-${local.context}-vpc"
  cidr = local.cidr

  azs             = local.azs
  private_subnets = local.private_subnets

  private_route_table_tags = { Name = "${var.name_prefix}-${local.context}-private" }
  private_subnet_tags      = { Name = "${var.name_prefix}-${local.context}-private" }

  enable_dhcp_options  = true
  enable_dns_hostnames = true
}

module "vpc_endpoints" {
  source = "github.com/MSIL-Analytics-ACE/terraform-common-modules//terraform-aws-vpc/modules/vpc-endpoints?ref=v1.0.0"

  vpc_id             = module.vpc.vpc_id
  security_group_ids = [module.vpc_endpoint_security_group.security_group_id]

  endpoints = { for key, value in local.vpc_endpoints : key => merge(value, {
    tags                = { Name = replace("${var.name_prefix}-${local.context}-${key}-vep", "_", "-") }
    private_dns_enabled = true
    subnet_ids          = module.vpc.private_subnets
  }) }
}


module "vpc_endpoint_security_group" {
  source = "github.com/MSIL-Analytics-ACE/terraform-common-modules//terraform-aws-security-group?ref=v1.0.0"

  name        = "${var.name_prefix}-${local.context}-vep-sg"
  description = "Security group for VPC endpoints"
  vpc_id      = module.vpc.vpc_id

  ingress_with_self = [
    {
      rule = "all-all"
    },
    {
      from_port   = 443
      to_port     = 443
      protocol    = "tcp"
      description = "Container to VPC endpoint service"
      self        = true
    },
  ]

  egress_cidr_blocks = ["0.0.0.0/0"]
  egress_rules       = ["https-443-tcp"]
}

/* - Implementation of SSM Param update on SM registry model approval event - */

resource "aws_ssm_parameter" "ssm_params" {

  for_each = local.sm_registry_approval_params

  name           = "/${var.name_prefix}-dapf-ssm/${local.context}/${each.key}"
  description    = each.value.description
  type           = "String"
  insecure_value = try(each.value.value, "default")
  lifecycle {
    ignore_changes = [
      insecure_value,
    ]
  }
}

resource "aws_cloudwatch_event_rule" "sm_registry_event" {

  name        = "${var.name_prefix}-sm-model-approval"
  description = "Rule to capture event generated on approval of model in sagemaker registry"

  event_pattern = jsonencode({
    detail-type = ["SageMaker Model Package State Change"],
    source      = ["aws.sagemaker"],
    detail = {
      ModelPackageGroupName = [var.model_package_group_name],
      ModelApprovalStatus   = ["Approved"]
    }
  })
}

module "lambda" {
  source = "github.com/MSIL-Analytics-ACE/terraform-common-modules//terraform-aws-lambda?ref=v1.0.0"

  function_name = "${var.name_prefix}-sm-model-approval-event-processor"
  description   = "Lambda function to consume sagemaker registry approval and update ssm parameter"
  handler       = "sm_registry_event_target.lambda_handler"
  runtime       = "python3.8"
  publish       = true

  source_path = "${path.module}/lambda/sm_registry_event_target.py"

  allowed_triggers = {
    sm_registry_event = {
      principal  = "events.amazonaws.com"
      source_arn = aws_cloudwatch_event_rule.sm_registry_event.arn
    }
  }

  environment_variables = merge({
    for k, v in aws_ssm_parameter.ssm_params : k => v.id
    }, {
    ssm_inference_sfn_inputs = coalesce(var.ssm_name_inference_sfn_inputs, "/${var.name_prefix}-dapf-ssm/inferencing_step_function_inputs")
  })
}

resource "aws_cloudwatch_event_target" "lambda_target" {

  rule = aws_cloudwatch_event_rule.sm_registry_event.id
  arn  = module.lambda.lambda_function_arn
}


/* --------------------- Cloudwatch Events (EventBridge) for EAP account -------------------- */

resource "aws_cloudwatch_event_rule" "scan_events" {

  for_each = local.events_from_evaluation

  event_bus_name = var.event_bus_name

  name        = "${each.key}-event"
  description = each.value.description
  event_pattern = jsonencode({
    source = [each.value.source_pattern]
  })
}
